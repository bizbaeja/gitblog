---
title: React 기본 개념정리
date: 2022-11-25
description: 예제
---

# 클래스 이해하기

```jsx
class Person {
  //가장 간단한 프로퍼티의 형태는 생성자 함수를 추가하는 것이다.
  //메소드는 메소드의 이름 다음에 중괄호를 넣어서 만든다
  //그리고 this 키워드로 프로퍼티를 설정할 수 있다.
  constructor() {
    this.name = '자현';
  }
  printMyName() {
    console.log(this.name);
  }
}
//만들어놓은 클래스를 new Person() 메소드를 사용해서 상수 person 에 저장한다.
const person = new Person();

person.printMyMame();

//>>> '자현' 이 출력된다.
```

## 클래스의 상속

```jsx
class Human {
	constructor() {
	this.gender = 'female';
 }
	printGender(){
	console.log(this.gender);
	}
}
//Person class 는 extend 키워드를 사용하여 human 클래스를 상속받아 확장할 수 있다.
class Person extends Human {
		//super 메소드를 추가해야 작동한다.
	 super();
   construtor(){
	this.name = '자현';
	}
   printMyName(){
	console.log(this.name);
	}
}
const person = new Person();
person.printMyName();
person.printGender();
```

## 클래스의 속성 및 메서드

```jsx
class Human {
  gender = 'female';

  printGender = () => {
    console.log(this.gender);
  };
}

class Person extends Human {
  name = '자현';
  gender = 'female';

  printMyName = () => {
    console.log(this.name);
  };
}

const person = new Person();
person.printMyName();
person.printGender();
```

# 스프레드 연산자

```jsx
const numbers = [1, 2, 3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);
//>>> [1,2,3,4]
```

```jsx
const person = { name: '자현' };
const newPerson = { ...person, age: 28 };

console.log(newPerson);
//>>> [object object] { age:28, name:"자현"}
```

## 레스트 연산자

```jsx
const filter = (...args) => {
  //배열 메소드를 fliter() 처럼 사용할 수 있고, filter 는 배열에서 전달되는 모든 원소들에 대해 함수실 힐행한다. 그래서 원소를 전달하고 화살표 함수를 하용해서 원소가 1과 같은지 아닌지를 true 나 false 로 반환한다.
  return args.filter((el) => el === 1);
};
console.log(filter(1, 2, 3));
//>>> [1]
```

## 구조분해할당

- 배열의 원소나 객체의 프로퍼티를 추출해서 변수에 저장할 수 있도록 해주는 것.
  ```jsx
  const numbers = [1, 2, 3];
  [num1, num2] = numbers;
  console.log(num1, num2);
  //>>> 1
  //>>> 2

  const numbers = [1, 2, 3];
  [num1, , num3] = numbers;
  console.log(num1, num3);
  //>>> 1
  //>>> 3
  ```

## 배열 함수

- (1) map \_ 예전 값을 새 값으로 반환한다.
  ```jsx
  //모든 원소의 값들이 두배가 되는 배열을 만들고 싶다
  const numbers = [1, 2, 3];

  const doubleNumArray = nubmers.map((num) => {
    return num * 2;
  });

  console.log(numbers);
  console.log(doubleNumArray);
  //>[1,2,3]
  //>[2,4,6]
  ```
- (2) reduce \_ (배열에 있는 모든 요소의 합계를 구할 때..)콜백 함수를 배열의 모든 값을 순서대로 실행하고 이전 요소에 대한 계산 값을 반환한다. 리듀서를 실행한 최종 결과는 단일 값이다. 콜백이 처음 실행될 때, ‘이전 계산의 반환 값’ 이 없다 제공된 경우 초기 값을 대신 사용할 수 있다. 그렇지 않으면 인덱스 0의 배열요소가 초기값으로 사용된다.
  ```jsx
  const arr = [1,2,3,4];
  const initialValue = 0;
  //accumulator : 콜백함수의 반환값을 누적한다
  //currentValeu : 배열의 현재 요소

  const sumWithInitial = arr.reduce
  ((accumulator , currentValue)
   => accumulator + currentValue,
   initialValue);

  // accumulator = 0 , currentValue =1, currenIndex = 0, result = 1
  // accumulator = 1 , currentValue =2, currentIndex =1, result = 3
  // accumulator = 3 , currentValue =3, currentIndex =2, result = 6
  // accumulator = 6 , currentValue =4, currentIndex =4, result = 10

  //>>> 10
  ```
